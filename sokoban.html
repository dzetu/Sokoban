<canvas
	id="myCanvas"
	width="600"
	height="300"></canvas>
<script>
/*
to do:
-desenam jocul
	- desenam o patratica
	- desenam mai multe tipuri de patratele: zid, player, cutie, floor si locul unde trebuie sa ajunga cutia
	- aranjam patratelele la anumite coordonate in functie de tipul patratelului
	- coordonam player-ul astfel incat sa ajunga de la o pozitie la alta
	- pentru fiecare tip de patratica punem o conditie:
		cutia sa se poate muta,
		plyaerul sa isi poate schimba pozitia si sa impinga cutia,
		zidul sa fie o bariera pentru cutie player
	- player-ul poate muta o singura cutie
	- cutia trebuie sa aiba un traseu posibil spre punctul final
-sa se afiseze "ai castigat!"
-miscarea cu animatii
-sa ramana acelasi cand dam refresh
-buton restart
-jucam cu mouse-ul highligth piesele care se pot muta
-centrare tabla
*/
var canvas = document.getElementById("myCanvas");
var ctx = canvas.getContext("2d");

// NOTE: all the lines of a level must have the same length!
var level = [
	"xxxxxxxxxxx",
	"x   x     x",
	"x   pbb   x",
	"x   b     x",
	"x   ooo   x",
	"xxxxxxxxxxx",
];

var string_to_array = function(level) {
	var a = [];
	for(var i = 0; i < level.length; i++){
		var l = level[i];
		a.push(l);
	}
	return a;
}
for(var i = 0; i < level.length; i++){
	level[i] = string_to_array(level[i]);
}

var draw_square = function(i,j,type) {
	var w = 50;
	var x = i * w;
	var y = j * w;
	ctx.beginPath();
	ctx.rect(x,y,w,w);
	if(type == "x"){
		ctx.fillStyle = "red";
		ctx.fill();
	}
	if(type == "p" || type == "P"){
		ctx.fillStyle = "black";
		ctx.fill();
	}
	if(type == "b" || type == "B"){
		ctx.fillStyle = "brown";
		ctx.fill();
	}
	if(type == "o"){
		ctx.fillStyle = "pink";
		ctx.fill();
	}
}
var draw_level = function(){
	ctx.beginPath();
	ctx.clearRect(0,0,canvas.width, canvas.height)
	for(var j = 0; j < level.length; j++){
		for(var i = 0; i < level[j].length; i++){
			var type = level[j][i];
			draw_square(i,j,type);
		}
	}
}
var find_player_pos = function() {
	for(var j = 0; j <= level.length; j++){
		for(var i = 0; i <= level[j].length; i++){
			if(level[j][i] == "p" || level[j][i] == "P"){
				return {j: j, i: i};
			}
		}
	}
}

var pos;
var key_down = function(event){

	// player's new position, set if the player moves.
	var new_pos;
	// box-that-was-pushed new position, set if the player moves.
	var new_pos_box;

	// find the position where the player should move at.
	// also find the position where an eventual box should move at.
	if(event.key=="ArrowUp"){
		new_pos = {j: pos.j-1, i: pos.i};
		new_pos_box = {j: pos.j-2, i: pos.i};
	}
	else if(event.key=="ArrowDown"){
		new_pos = {j: pos.j+1, i: pos.i};
		new_pos_box = {j: pos.j+2, i: pos.i};
	}
	else if(event.key=="ArrowRight"){
		new_pos = {j: pos.j, i: pos.i+1};
		new_pos_box = {j: pos.j, i: pos.i+2};
	}
	else if(event.key=="ArrowLeft"){
		new_pos = {j: pos.j, i: pos.i-1};
		new_pos_box = {j: pos.j, i: pos.i-2};
	}

	// player didn't move, some other key must have been pressed.
	if (!new_pos)
		return;

	// exit if the box-to-be-moved' new position is outside the
	// level bounds.
	if (new_pos_box.j < 0)
		return;
	if (new_pos_box.i < 0)
		return;
	if (new_pos_box.j >= level.length)
		return;
	if (new_pos_box.i >= level[0].length)
		return;

	// c1: what is at player's initial position
	// c2: what is at player's new position
	// c3: what is at box's new position
	var c1 = level[pos.j][pos.i];
	var c2 = level[new_pos.j][new_pos.i];
	var c3 = level[new_pos_box.j][new_pos_box.i];

	// b1: what is at the player's new position
	// b2: what is at the eventual box's new position
	var b1 = c2;
	var b2 = c3;
	var can_move = true;

	// decide what to leave in player's place.
	// if player's on a box dest. then it leaves behind an empty dest,
	// else it leaves behind a space.
	if(c1 == "P"){
		c1 = "o";
	} else {
		c1 = " ";
	}

	// decide what to put where the player moves and if the player
	// can actually move.
	// if the player steps on a dest. (with or without a box on it)
	//	then it becomes "a player on a dest".
	if(c2 == "o" || c2 == "B"){
		c2 = "P";
	}
	// if the player steps on a space or a box then it becomes a player.
	else if(c2 == " " || c2 == "b"){
		c2 = "p";
	yh}
	// in all other cases, the player cannot move.
	else{
		can_move = false;
	}

	// decide what to put where the box moves and if the box can actually
	// be moved, and therefore if the player can be moved.
	// if the player pushes a box (i.e. there's a box at player's new pos)
	if(b1 == "b" || b1 == "B"){
		// if in front of the box there's a space, we put a box there.
		if(b2 == " "){
			b2 = "b";
		}
		// if in front of the box there's a dest., we put a
		// "box on a dest" there.
		else if(b2 == "o"){
			b2 = "B"
		}
		// in all othere cases, the box can't move,
		// therefore the player can't move.
		else{
			can_move = false;
		}
	}

	// exit if we figured that we can't move the player or the box.
	if (!can_move)
		return;

	// we put back into the level the new values of the squares.
	level[pos.j][pos.i] = c1;
	level[new_pos.j][new_pos.i] = c2;
	level[new_pos_box.j][new_pos_box.i] = b2;

	pos = new_pos;

	draw_level();
}
draw_level();
pos = find_player_pos();
addEventListener("keydown", key_down)
</script>
